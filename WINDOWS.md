## 软链接 硬链接 快捷方式

### 软链接
执行命令 mklink link_name target_name  
创建链接后的图标和快捷方式很像, 都有一个箭头的标志  
在系统中不占用空间  
在文件系统中不是一个单独的文件  
在操作系统层解析  
如果源文件被删除了，链接就没用了  
移除源文件不会影响符号链接  
移除链接文件也不会影响源文件  
win10_x64_build10565上测试不可以右键修改图标和设置管理员运行  
文件大小为0字节和不占用空间  
文件属性的创建时间和修改时间都是软链接创建和修改时的时间  
文件类型是.SYMLINK  
可以在cmd下运行软链接(假如链接的是程序, 且运行命令是XXX即可)(win10_x64_build10565上测试通过)  

### 硬链接
执行命令 mklink /H link_name target_name  
在系统中占用的空间与源文件相同，但在系统中引用的是相同的对象（不是拷贝）  
在操作系统层解析  
图标和创建快捷方式的图标不同(没有快捷方式的小箭头)  
移除源文件不会影响硬链接  
移除硬链接不会影响源文件  
如果源文件被删除，它的内容依然通过硬链接存在  
硬链接文件的任何更改都会影响到源文件  
文件大小, 占用空间, 创建和修改时间跟源文件一样  
可以在cmd下运行硬连接(假如链接的是程序)  

### 快捷方式
在选择的源文件上鼠标右键，通过右键菜单创建  
快捷方式在系统中跟源文件是完全分离的  
只有那些懂得快捷方式的程序知道它们  
如果源文件删除，链接就没用了  
移除源文件不会移除快捷方式  
移除快捷方式不会影响到源文件  
可以右键更改图标或者设置管理员运行  
文件属性的创建时间和修改时间都是快捷方式创建和修改时的时间  
文件大小仅有几百字节, 跟原文件大小无关  
文件类型是.lnk  
可以在cmd下运行快捷方式(假如链接的是程序, 且运行命令是XXX.LNK)(win10_x64_build10565上测试通过)  

### junction
替代mklink指令，不需要管理员权限运行cmd -> <https://www.jianshu.com/p/a31a679c500b>  
```
// To create a junction c:\Program-Files for "c:\Program Files":
junction c:\Program-Files "c:\Program Files"
```

## CPU 核心 线程
线程是个操作系统中虚拟的概念。一个线程是一个应用程序中的一部分，负责执行程序中部分计算任务。
多个线程可以并存，且不依赖于CPU核心的数量。只有一个CPU核心时，这个核心一会执行一个线程，一会又执行另一个线程，在线程中切换。
因为切换的速度很快（微秒级别），人感觉不到，从而造成一种所有线程（程序）在同时运行的错觉。
就像快速翻画书就会产生动画的错觉一样。实际上，一个CPU核心在同一时刻只能执行一个线程。

Intel的中高端CPU有一种超线程技术，可以让一个CPU核心同时执行2个线程。为了产品宣传，经常说什么双核四线程，四核八线程。
实际上这里指的是CPU可以真正同时地跑多少个线程。假设操作系统里有8个线程在跑，如果电脑只有1个CPU核心的话，那么这8个线程永远不能同时执行，而是轮流执行。
如果有2个核心，那么有2个线程可以同时跑。如果有8个核心，那么所有线程都可以真正同时跑起来，而不是快速切换造成的错觉。

如果线程/核心这个概念是行，那流水线就是列，两者正交，不相干。
说到行和列，整个CPU就像是一张表格，把格子填得越满利用率就越高效率也应当越高。
代码像一段水柱一样在一行内流过去，划分流水线/列就是为了在时间上充分利用各个单元。
而超标量多发射就是指有些单元格里能存在多段水柱（硬件上有多个单元），此时乱序发射可以激进地在时空上利用各个单元。
而超线程创造的“多个逻辑核心”，可以在线程代码以及外部约束情况下，让另一个线程挤进来填充空间。总的来说就是一个目的，减少指令空泡，提高资源利用率。

#### CPU架构

要谈超线程和多核，就不得不谈CPU的架构和逻辑。无关的技术细节太多，这里略去。我们重点谈一下CPU中两个相关的模块：
1）Processing Unit（运算处理单元），简称PU
2）Architectual State（架构状态单元），简称AS
PU一般就是执行运算，比如算数运算加减乘除。AS执行一些逻辑和调度方面的操作，比如控制内存访问等。

单核CPU（先从简单的谈起）
一般一块传统意义的CPU上会有一个PU、一个AS。

比喻：一个小饭馆（单核CPU），夫妻老婆店，老板兼大厨厨房炒菜，老板娘兼服务员点单。这不，来了一个客人，首先，走到老板娘的收银台前，看菜单准备点单。差不多5分钟后，客人点完了一份盖浇饭。老板娘抄好了单，递给了在后厨的老公。老公开始炒菜。在这个例子中，老板娘可以理解成AS，老板/大厨可以理解称PU（干实事的）。

多核CPU
这里说的多核，是多个物理核，比如i3的双核，i5的4核。这中架构下，每一个物理核都有一个PU和一个AS。所以。对于i3来说，就有总共两个PU，两个AS。对于i5来说，就有总过4个PU，4个AS。

比喻：上面小饭馆的列子，对于5、6个客人可能还能忙的过来。但设想一下子来他个16个客人，这队估计要排到街上了。如果再告诉你，每10分种就有16个新客人过来点单。。。完了。生意估计是做不下去了 - 老板、老板娘忙到死。
这时，我们就需要一个更大的单位食堂（多核CPU）。有4个服务生、4个大厨。4个服务生同时点单，4个大厨同时开炒（1号服务生专给一号大厨下单，二号服务神生专给二号大厨下单。。。以此类推）。这样相比小饭馆一个老板娘、一个客人队列，这里成了4个队列，效率顿时比小饭馆提高4倍。16个客人，平均分配成4个队列，每个队列就只有4个客人了，情况是不是好了很多？

这个应该还是比较容易理解的。

超线程技术(HT)
重头戏来了，超线程是个啥玩意。他是我们平时说的多线程吗？
超线程(HT)并不是我们一般说的多线程。我们一般说的多线程（multi-threading）是指程序方面的，简单的说就是‘软’的，代码级别的。而超线程一般指的是硬件架构方面的，是‘硬’的：通过调整AS而模拟出来的‘逻辑核’。
简单的说吧，超线程就是一个物理核里面，有两个AS，一个PU。两个AS共享一个PU。为什么这么做，看下面的例子：

比喻：刚刚那个单位食堂，4个服务生，4个大厨，4个队列。会不会效率问题？
有！
设想每个客人都有看单选单的时候，你能保证每个客人都看两眼就下单？有的客人难免会磨磨蹭蹭，问东问西，一个菜点它个15分钟。而设想大厨平均炒一个菜只要10分种。那剩下的那5分钟呢？大厨在厨房闲着没事干，喝茶看报纸。时间全被客人-服务生点菜这个环节给浪费掉了。

那有没有解决方法？我想大家应该都能猜出来了
--- 增加服务生！

这时候，我们给每个大厨多增加一个服务生，从一个服务生变成了两个服务生（AS），服务生1A和服务生1B开两个队列，同时给一个大厨（PU）下单。这样，当出现服务生1A的客人15分钟单子都没有下完的情况下，1B的客人单子很有可能3分钟下好送给大厨开炒了（PU），这样大厨就不会站在厨房傻等1A客人的订单。这样，最大限度地榨干大厨的劳动力 （大厨估计要骂娘了），而对于CPU来说，最大限度的提高了CPU的使用率，减少了CPU的（IDLE）空闲时间。有的时候，真不能怪大厨（PU）不卖力，而是你服务生（AS）叫单太墨迹。


